syntax = "proto3";

package ory.keto.relation_tuples.v1alpha2;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/api/visibility.proto";
import "ory/keto/relation_tuples/v1alpha2/relation_tuples.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option csharp_namespace = "Ory.Keto.RelationTuples.v1alpha2";
option go_package = "github.com/ory/keto/proto/ory/keto/relation_tuples/v1alpha2;rts";
option java_multiple_files = true;
option java_outer_classname = "CheckServiceProto";
option java_package = "sh.ory.keto.relation_tuples.v1alpha2";
option php_namespace = "Ory\\Keto\\RelationTuples\\v1alpha2";

// The service that performs authorization checks
// based on the stored Access Control Lists.
//
// This service is part of the [read-APIs](../concepts/25_api-overview.mdx#read-apis).
service CheckService {
  // Performs an authorization check.
  rpc Check(CheckRequest) returns (CheckResponse) {
    option (google.api.http) = {
      get: "/relation-tuples/check"
      additional_bindings: {get: "/relation-tuples/check/openapi"}
      additional_bindings: {
        post: "/relation-tuples/check"
        body: "*"
      }
      additional_bindings: {
        post: "/relation-tuples/check/openapi"
        body: "*"
      }
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      consumes: "application/x-www-form-urlencoded"
      consumes: "application/json"
      tags: "permission"
      responses: {
        key: "200"
        value: {
          description: "The response of the permission check, in case it is allowed. For the `/openapi` endpoints, the status code is always 200."
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.CheckResponse"}
          }
        }
      }
      responses: {
        key: "403"
        value: {
          description: "The response of the permission check, in case it is not allowed. For the `/openapi` endpoints, the status code is always 200."
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.CheckResponse"}
          }
        }
      }
      responses: {
        key: "400";
        value: {
          description: "errorGeneric";
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.ErrorResponse"}
          }
        };
      };
      responses: {
        key: "default";
        value: {
          description: "errorGeneric";
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.ErrorResponse"}
          }
        };
      };
    };
  }

  // Performs an authorization check for a batch of tuples.
  //
  // To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
  rpc BatchCheck(BatchCheckRequest) returns (BatchCheckResponse) {
    option (google.api.http) = {
      post: "/relation-tuples/batch/check"
      body: "rest_body"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      consumes: "application/json"
      tags: "permission"
      operation_id: "batchCheckPermission";
      responses: {
        key: "200"
        value: {
          description: "The response of the permission check, in case it is allowed. For the `/openapi` endpoints, the status code is always 200."
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.BatchCheckResponse"}
          }
        }
      }
      responses: {
        key: "400";
        value: {
          description: "errorGeneric";
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.ErrorResponse"}
          }
        };
      };
      responses: {
        key: "default";
        value: {
          description: "errorGeneric";
          schema: {
            json_schema: {ref: ".ory.keto.relation_tuples.v1alpha2.ErrorResponse"}
          }
        };
      };
    };
  }
}

// The request for a CheckService.Check RPC.
// Checks whether a specific subject is related to an object.
message CheckRequest {
  // The namespace to evaluate the check.
  //
  // Note: If you use the expand-API and the check
  // evaluates a RelationTuple specifying a SubjectSet as
  // subject or due to a rewrite rule in a namespace config
  // this check request may involve other namespaces automatically.
  string namespace = 1 [deprecated = true];
  // The related object in this check.
  string object = 2 [deprecated = true];
  // The relation between the Object and the Subject.
  string relation = 3 [deprecated = true];
  // The related subject in this check.
  Subject subject = 4 [
    deprecated = true,
    (google.api.field_visibility).restriction = "NO_SWAGGER"
  ];

  oneof rest_api_subject {
    // A concrete id of the subject.
    string subject_id = 9 [
      deprecated = true,
      json_name = "subject_id"
    ];
    // A subject set that expands to more Subjects.
    // More information are available under [concepts](../concepts/subjects.mdx).
    SubjectSetQuery subject_set = 10 [
      deprecated = true,
      json_name = "subject_set"
    ];
  }

  RelationTuple tuple = 8 [(google.api.field_visibility).restriction = "NO_SWAGGER"];

  // This field is not implemented yet and has no effect.
  // <!--
  // Set this field to `true` in case your application
  // needs to authorize depending on up to date ACLs,
  // also called a "content-change check".
  //
  // If set to `true` the `snaptoken` field is ignored,
  // the check is evaluated at the latest snapshot
  // (globally consistent) and the response includes a
  // snaptoken for clients to store along with object
  // contents that can be used for subsequent checks
  // of the same content version.
  //
  // Example use case:
  //  - You need to authorize a user to modify/delete some resource
  //    and it is unacceptable that if the permission to do that had
  //    just been revoked some seconds ago so that the change had not
  //    yet been fully replicated to all availability zones.
  // -->
  bool latest = 5 [(google.api.field_visibility).restriction = "NO_SWAGGER"];
  // This field is not implemented yet and has no effect.
  // <!--
  // Optional. Like reads, a check is always evaluated at a
  // consistent snapshot no earlier than the given snaptoken.
  //
  // Leave this field blank if you want to evaluate the check
  // based on eventually consistent ACLs, benefiting from very
  // low latency, but possibly slightly stale results.
  //
  // If the specified token is too old and no longer known,
  // the server falls back as if no snaptoken had been specified.
  //
  // If not specified the server tries to evaluate the check
  // on the best snapshot version where it is very likely that
  // ACLs had already been replicated to all availability zones.
  // -->
  string snaptoken = 6 [(google.api.field_visibility).restriction = "NO_SWAGGER"];
  // The maximum depth to search for a relation.
  //
  // If the value is less than 1 or greater than the global
  // max-depth then the global max-depth will be used instead.
  int32 max_depth = 7 [json_name = "max-depth"];
}

// The response for a permission check.
message CheckResponse {
  // Whether the specified subject (id)
  // is related to the requested object.
  //
  // It is false by default if no ACL matches.
  bool allowed = 1 [(google.api.field_behavior) = REQUIRED];
  // This field is not implemented yet and has no effect.
  // <!--
  // The last known snapshot token ONLY specified if
  // the request had not specified a snaptoken,
  // since this performed a "content-change request"
  // and consistently fetched the last known snapshot token.
  //
  // This field is not set if the request had specified a snaptoken!
  //
  // If set, clients should cache and use this token
  // for subsequent requests to have minimal latency,
  // but allow slightly stale responses (only some milliseconds or seconds).
  // -->
  string snaptoken = 2 [(google.api.field_visibility).restriction = "NO_SWAGGER"];
}

// The response for an individual check in the CheckService.BatchCheck rpc.
message CheckResponseWithError {
  // Whether the specified subject (id)
  // is related to the requested object.
  //
  // It is false by default if no ACL matches.
  bool allowed = 1 [(google.api.field_behavior) = REQUIRED];
  // If there was an error checking the tuple,
  // this will contain the error message.
  //
  // If the check was performed successfully, this will be empty.
  string error = 2;
  // This field is not implemented yet and has no effect.
  // <!--
  // The last known snapshot token ONLY specified if
  // the request had not specified a snaptoken,
  // since this performed a "content-change request"
  // and consistently fetched the last known snapshot token.
  //
  // This field is not set if the request had specified a snaptoken!
  //
  // If set, clients should cache and use this token
  // for subsequent requests to have minimal latency,
  // but allow slightly stale responses (only some milliseconds or seconds).
  // -->
  string snaptoken = 3 [(google.api.field_visibility).restriction = "NO_SWAGGER"];
}

message BatchCheckRequestBody {
  repeated RelationTuple tuples = 1;
}

// The request for a CheckService.BatchCheck RPC.
// Checks a batch of relations.
message BatchCheckRequest {
  repeated RelationTuple tuples = 1 [(google.api.field_visibility).restriction = "NO_SWAGGER"];

  // Batch Check Permission Body.
  BatchCheckRequestBody rest_body = 5 [
    deprecated = true,
    json_name = "body"
  ];

  // This field is not implemented yet and has no effect.
  // <!--
  // Set this field to `true` in case your application
  // needs to authorize depending on up to date ACLs,
  // also called a "content-change check".
  //
  // If set to `true` the `snaptoken` field is ignored,
  // the check is evaluated at the latest snapshot
  // (globally consistent) and the response includes a
  // snaptoken for clients to store along with object
  // contents that can be used for subsequent checks
  // of the same content version.
  //
  // Example use case:
  //  - You need to authorize a user to modify/delete some resource
  //    and it is unacceptable that if the permission to do that had
  //    just been revoked some seconds ago so that the change had not
  //    yet been fully replicated to all availability zones.
  // -->
  bool latest = 2 [(google.api.field_visibility).restriction = "NO_SWAGGER"];
  // This field is not implemented yet and has no effect.
  // <!--
  // Optional. Like reads, a check is always evaluated at a
  // consistent snapshot no earlier than the given snaptoken.
  //
  // Leave this field blank if you want to evaluate the check
  // based on eventually consistent ACLs, benefiting from very
  // low latency, but possibly slightly stale results.
  //
  // If the specified token is too old and no longer known,
  // the server falls back as if no snaptoken had been specified.
  //
  // If not specified the server tries to evaluate the check
  // on the best snapshot version where it is very likely that
  // ACLs had already been replicated to all availability zones.
  // -->
  string snaptoken = 3 [(google.api.field_visibility).restriction = "NO_SWAGGER"];
  // The maximum depth to search for a relation.
  //
  // If the value is less than 1 or greater than the global
  // max-depth then the global max-depth will be used instead.
  int32 max_depth = 4 [json_name = "max-depth"];
}

// The response for a CheckService.BatchCheck rpc.
message BatchCheckResponse {
  // The results of the batch check. The order of these
  // results will match the order of the input.
  repeated CheckResponseWithError results = 1;
}
