// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file ory/keto/relation_tuples/v1alpha2/check_service.proto (package ory.keto.relation_tuples.v1alpha2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { RelationTuple, Subject } from "./relation_tuples_pb.js";

/**
 * The request for a CheckService.Check RPC.
 * Checks whether a specific subject is related to an object.
 *
 * @generated from message ory.keto.relation_tuples.v1alpha2.CheckRequest
 */
export class CheckRequest extends Message<CheckRequest> {
  /**
   * The namespace to evaluate the check.
   *
   * Note: If you use the expand-API and the check
   * evaluates a RelationTuple specifying a SubjectSet as
   * subject or due to a rewrite rule in a namespace config
   * this check request may involve other namespaces automatically.
   *
   * @generated from field: string namespace = 1 [deprecated = true];
   * @deprecated
   */
  namespace = "";

  /**
   * The related object in this check.
   *
   * @generated from field: string object = 2 [deprecated = true];
   * @deprecated
   */
  object = "";

  /**
   * The relation between the Object and the Subject.
   *
   * @generated from field: string relation = 3 [deprecated = true];
   * @deprecated
   */
  relation = "";

  /**
   * The related subject in this check.
   *
   * @generated from field: ory.keto.relation_tuples.v1alpha2.Subject subject = 4 [deprecated = true];
   * @deprecated
   */
  subject?: Subject;

  /**
   * @generated from field: ory.keto.relation_tuples.v1alpha2.RelationTuple tuple = 8;
   */
  tuple?: RelationTuple;

  /**
   * This field is not implemented yet and has no effect.
   * <!--
   * Set this field to `true` in case your application
   * needs to authorize depending on up to date ACLs,
   * also called a "content-change check".
   *
   * If set to `true` the `snaptoken` field is ignored,
   * the check is evaluated at the latest snapshot
   * (globally consistent) and the response includes a
   * snaptoken for clients to store along with object
   * contents that can be used for subsequent checks
   * of the same content version.
   *
   * Example use case:
   *  - You need to authorize a user to modify/delete some resource
   *    and it is unacceptable that if the permission to do that had
   *    just been revoked some seconds ago so that the change had not
   *    yet been fully replicated to all availability zones.
   * -->
   *
   * @generated from field: bool latest = 5;
   */
  latest = false;

  /**
   * This field is not implemented yet and has no effect.
   * <!--
   * Optional. Like reads, a check is always evaluated at a
   * consistent snapshot no earlier than the given snaptoken.
   *
   * Leave this field blank if you want to evaluate the check
   * based on eventually consistent ACLs, benefiting from very
   * low latency, but possibly slightly stale results.
   *
   * If the specified token is too old and no longer known,
   * the server falls back as if no snaptoken had been specified.
   *
   * If not specified the server tries to evaluate the check
   * on the best snapshot version where it is very likely that
   * ACLs had already been replicated to all availability zones.
   * -->
   *
   * @generated from field: string snaptoken = 6;
   */
  snaptoken = "";

  /**
   * The maximum depth to search for a relation.
   *
   * If the value is less than 1 or greater than the global
   * max-depth then the global max-depth will be used instead.
   *
   * @generated from field: int32 max_depth = 7;
   */
  maxDepth = 0;

  constructor(data?: PartialMessage<CheckRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ory.keto.relation_tuples.v1alpha2.CheckRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subject", kind: "message", T: Subject },
    { no: 8, name: "tuple", kind: "message", T: RelationTuple },
    { no: 5, name: "latest", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "snaptoken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "max_depth", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckRequest {
    return new CheckRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckRequest {
    return new CheckRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckRequest {
    return new CheckRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckRequest | PlainMessage<CheckRequest> | undefined, b: CheckRequest | PlainMessage<CheckRequest> | undefined): boolean {
    return proto3.util.equals(CheckRequest, a, b);
  }
}

/**
 * The response for a CheckService.Check rpc.
 *
 * @generated from message ory.keto.relation_tuples.v1alpha2.CheckResponse
 */
export class CheckResponse extends Message<CheckResponse> {
  /**
   * Whether the specified subject (id)
   * is related to the requested object.
   *
   * It is false by default if no ACL matches.
   *
   * @generated from field: bool allowed = 1;
   */
  allowed = false;

  /**
   * This field is not implemented yet and has no effect.
   * <!--
   * The last known snapshot token ONLY specified if
   * the request had not specified a snaptoken,
   * since this performed a "content-change request"
   * and consistently fetched the last known snapshot token.
   *
   * This field is not set if the request had specified a snaptoken!
   *
   * If set, clients should cache and use this token
   * for subsequent requests to have minimal latency,
   * but allow slightly stale responses (only some milliseconds or seconds).
   * -->
   *
   * @generated from field: string snaptoken = 2;
   */
  snaptoken = "";

  constructor(data?: PartialMessage<CheckResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ory.keto.relation_tuples.v1alpha2.CheckResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "snaptoken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckResponse {
    return new CheckResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckResponse {
    return new CheckResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckResponse {
    return new CheckResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckResponse | PlainMessage<CheckResponse> | undefined, b: CheckResponse | PlainMessage<CheckResponse> | undefined): boolean {
    return proto3.util.equals(CheckResponse, a, b);
  }
}

