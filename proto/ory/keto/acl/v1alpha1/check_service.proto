syntax = "proto3";

package ory.keto.acl.v1alpha1;

import "ory/keto/acl/v1alpha1/acl.proto";

option go_package = "github.com/ory/keto/proto/ory/keto/acl/v1alpha1;acl";
option csharp_namespace = "Ory.Keto.Acl.V1Alpha1";
option java_multiple_files = true;
option java_outer_classname = "CheckServiceProto";
option java_package = "sh.ory.keto.acl.v1alpha1";
option php_namespace = "Ory\\Keto\\Acl\\V1alpha1";

// The service that performs authorization checks
// based on the stored Access Control Lists.
service CheckService {
  // Check performs an authorization check.
  rpc Check(CheckRequest) returns (CheckResponse);
}

// The request for a CheckService.Check rpc.
// Checks whether a specific subject is related to an object.
message CheckRequest {
  // The namespace to evaluate the check.
  //
  // Note: If you use the expand API and the check
  // evaluates a RelationTuple specifying a SubjectSet as
  // subject or due to a rewrite rule in a namespace config
  // this check request may involve other namespaces automatically.
  string namespace = 1;
  // The related object in this check.
  string object = 2;
  // The relation between the Object and the Subject.
  string relation = 3;
  // The related subject to check against.
  Subject subject = 4;
  // Set this field to `true` in case your application
  // needs to authorize depending on up to date ACLs,
  // also called a "content-change check".
  //
  // If set to `true` the `snaptoken` field is ignored,
  // the check is evaluated at the latest snapshot
  // (globally consistent) and the response includes a
  // snaptoken for clients to store along with object
  // contents that can be used for subsequent checks
  // of the same content version.
  //
  // Example use case:
  //  - You need to authorize a user to modify/delete some resource
  //    and it is unacceptable that if the permission to do that had
  //    just been revoked some seconds ago so that the change had not
  //    yet been fully replicated to all availability zones.
  bool latest = 5;
  // Optional. Like reads, a check is always evaluated at a
  // consistent snapshot no earlier than the given snaptoken.
  //
  // Leave this field blank if you want to evaluate the check
  // based on eventually consistent ACLs, benefiting from very
  // low latency, but possibly slightly stale results.
  //
  // If the specified token is too old and no longer known,
  // the server falls back as if no snaptoken had been specified.
  //
  // If not specified the server tries to evaluate the check
  // on the best snapshot version where it is very likely that
  // ACLs had already been replicated to all availability zones.
  string snaptoken = 6;
}

// The response for a CheckService.Check rpc.
message CheckResponse {
  // Whether the specified subject (id)
  // is related to the requested object.
  //
  // It is false by default if no ACL matches.
  bool allowed = 1;
  // The last known snapshot token ONLY specified if
  // the request had not specified a snaptoken,
  // since this performed a "content-change request"
  // and consistently fetched the last known snapshot token.
  //
  // This field is not set if the request had specified a snaptoken!
  //
  // If set, clients should cache and use this token
  // for subsequent requests to have minimal latency,
  // but allow slightly stale responses (only some milliseconds or seconds).
  string snaptoken = 2;
}
